package jwa

import (
	"crypto"
	"encoding/json"
	"fmt"
	"io"
	"net"
)

// PublicKey is a generic interface for a JWK Public Key.
type PublicKey interface {
	// KeyType returns the JWK key type for this key. For elliptic curve keys,
	// this value should be "EC". For RSA keys, this value should be "RSA".
	KeyType() string
	// KeyID returns a distinct identifier which is unique to this Public Key.
	// The format generated by this library is a base32 encoding of a 240 bit
	// hash of the public key data divided into 12 groups like so:
	//    ABCD:EFGH:IJKL:MNOP:QRST:UVWX:YZ23:4567:ABCD:EFGH:IJKL:MNOP
	KeyID() string
	// Verify verifyies the signature of the data in the io.Reader using this
	// Public Key. The alg parameter should be the name of the JWA digital
	// signature algorithm which was used to produce the signature and should
	// be supported by this public key. Returns a nil error if the signature
	// is valid.
	Verify(data io.Reader, alg string, signature []byte) error
	// CryptoPublicKey returns the internal object which can be used as a
	// crypto.PublicKey for use with other standard library operations. The type
	// is either *rsa.PublicKey or *ecdsa.PublicKey
	CryptoPublicKey() crypto.PublicKey
	// These public keys can be serialized to the standard JSON encoding for
	// JSON Web Keys. See section 6 of the IETF draft RFC for JOSE JSON Web
	// Algorithms.
	json.Marshaler
}

// PrivateKey is a generic interface for a JWK Private Key.
type PrivateKey interface {
	// A JWA PrivateKey contains all fields and methods of a PublicKey of the
	// same type. The json.Marshaler method also outputs the private key data.
	PublicKey
	// PublicKey returns the JWK PublicKey associated with this PrivateKey.
	PublicKey() PublicKey
	// Sign signs the data read from the io.Reader using a signature algorithm
	// supported by the private key. If the specified hashing algorithm is
	// supported by this key, that hash function is used to generate the
	// signature otherwise the the default hashing algorithm for this key is
	// used. Returns the signature and the name of the JWK signature algorithm
	// used: "ES256", "ES384", or "ES512" for elliptic curve keyys and
	// "RS256", "RS384", or "RS512" for RSA keys.
	Sign(data io.Reader, hashID crypto.Hash) (signature []byte, alg string, err error)
	// CryptoPrivateKey returns the internal object which can be used as a
	// crypto.PublicKey for use with other standard library operations. The
	// type is either *rsa.PublicKey or *ecdsa.PublicKey
	CryptoPrivateKey() crypto.PrivateKey
	// GeneratePEMKey generates a PEM encoded block of a the internal private
	// key for use as an X509 key pair suitable for TLS and other functions.
	GeneratePEMKey() (key []byte, err error)
	// GeneratePEMCert generates a PEM encoded block of a certificate with
	// this key as the issuer and the given public key as the subject. Using
	// this key as the argument generates a self-signed certificate. The CN
	// field of the certificate's Distinguished Name will be the KeyID of
	// the given PublicKey. To make a certificate usable for a TLS server,
	// specify the domains and/or ipAddresses for the server, otherwise these
	// arguments can be nil.
	GeneratePEMCert(pub PublicKey, domains []string, ipAddresses []net.IP) (cert []byte, err error)
}

// UnmarshalPublicKeyJSON unmarshals the given JSON into a generic JWK Public Key
func UnmarshalPublicKeyJSON(data []byte) (PublicKey, error) {
	jwk := make(map[string]interface{})

	err := json.Unmarshal(data, &jwk)
	if err != nil {
		return nil, fmt.Errorf(
			"decoding JWK Public Key JSON data: %s\n", err,
		)
	}

	// Get the Key Type value.
	kty, err := stringFromMap(jwk, "kty")
	if err != nil {
		return nil, fmt.Errorf("JWK Public Key type: %s", err)
	}

	switch {
	case kty == "EC":
		// Call out to unmarshal EC public key.
		return ecPublicKeyFromMap(jwk)
	case kty == "RSA":
		// Call out to unmarshal RSA public key.
		return rsaPublicKeyFromMap(jwk)
	default:
		return nil, fmt.Errorf(
			"JWK Public Key type not supported: %q\n", kty,
		)
	}
}

// UnmarshalPrivateKeyJSON unmarshals the given JSON into a generic JWK Private Key
func UnmarshalPrivateKeyJSON(data []byte) (PrivateKey, error) {
	jwk := make(map[string]interface{})

	err := json.Unmarshal(data, &jwk)
	if err != nil {
		return nil, fmt.Errorf(
			"decoding JWK Private Key JSON data: %s\n", err,
		)
	}

	// Get the Key Type value.
	kty, err := stringFromMap(jwk, "kty")
	if err != nil {
		return nil, fmt.Errorf("JWK Private Key type: %s", err)
	}

	switch {
	case kty == "EC":
		// Call out to unmarshal EC private key.
		return ecPrivateKeyFromMap(jwk)
	case kty == "RSA":
		// Call out to unmarshal RSA private key.
		return rsaPrivateKeyFromMap(jwk)
	default:
		return nil, fmt.Errorf(
			"JWK Private Key type not supported: %q\n", kty,
		)
	}
}
