# libtrust TLS

Libtrust contains a set of tools for generating X509 certificates and CA
pools from the managed keys for use in TLS.  These certificates are
self-signed by a key managed by libtrust and the fingerprint of a libtrust
public key is used as the X509 common name.  Certificates generated by
libtrust may be verified by CA certificates generated by libtrust, however
these certificates may not be able to be verified by non-libtrust CAs.  To
use libtrust keys with non-libtrust PKI, a CSR will need to be generated
with the libtrust key and signed by the used PKI.

## Motivation
Conventional PKI can be burdensome to setup and unnecessary when a
small number of machines are involved.  Even though TLS is the leading
standard for secure connections, its required use of X509 is much more
difficult to setup compared to SSH. Setting up SSH authentication
between machines is familiar to developers and administrators and
rarely regarded as being as difficult as configuring TLS connections.  The
goal of the libtrust X509 tools is to provide an alternative method than
conventional PKI for TLS configuration without sacrificing security.
Configuring TLS with libtrust uses a method which should be familiar to
anyone who uses SSH for client/server connections.

## Identity-based Authentication
Identity based authentication uses the authenticated public key of the
client and server TLS certificates to identify the client and host.
The public key identity is used to authorize establishment of the
connection through standard TLS CA verification. These identities may
also be used in the application for further authorization.   Libtrust
provides tooling for configuring TLS for identity authentication using
the libtrust managed keys by providing key lists to the both the client
and server to generate the CA verification pool.  To use the tools the
client will have a list of known host public keys and the server will have
a list of authorized client keys.

### Authorized Keys
The authorized keys list is used by TLS servers as a list of public keys
which will be allowed to connect with no further authorization.  The
public key authentication is done by the TLS protocol.  The client
provides a certificate self-signed by its key and with the common name
as the public key fingerprint.  The server will create a CA pool of
certificates self-signed with its own key and a CA certificate with the
certificate key as the public key and the common name as the key
fingerprint for each authorized key.

Authorized keys are managed by either a single file which contains
a list of public keys or a directory containing public key files (one
public key per file).  The file containing the list of public keys may
either be in JSON format or PEM format.  The public key file directory
can contain files of both JSON (JWK format) and PEM.

#### JSON Web Key format
The JSON Web Key (JWK) format is a JSON representation of a public
or private key.  For use as an authorized key, the private part of the
key is not needed and for security reasons not included.  The kid is
the fingerprint of the public key and used to make key identification
easier for human readers.

~~~~
{
    "crv": "P-256",
    "kid": "6EWQ:QBGP:5CXA:QBHI:DLXJ:IRMO:47H7:EIDB:3QZR:S3MZ:UEMP:J6J5",
    "kty": "EC",
    "x": "1cuD55uO-hSfHPfg6GwsShsropJD4FGQqJvU-4vnuxo",
    "y": "pv1OFj8b3B9IBFFVv91h8KGPj3Xs4L2gR4AgMRV2IDA"
}
~~~~

#### JSON format
The JSON format for a single file containing multiple keys contains
a simple JSON object with key named "keys" and value of an array of
JSON Web Keys as described above.

~~~~
{
  "keys": [
    {
      "crv": "P-256",
      "kid": "2U42:NG6Y:2TSP:YVIQ:4LEW:4Z2G:NJYV:6JOJ:R3ST:ZBOS:JGOQ:4MXO",
      "kty": "EC",
      "x": "MikDjKvzG7oSLO4sB9mWuneRuGQW7o694nOZKWUVpCY",
      "y": "WLQGLscMaCUzvDRYt2QBKwX9mEyutymQCvywgeqwESw"
    },
    {
      "crv": "P-256",
      "kid": "6EWQ:QBGP:5CXA:QBHI:DLXJ:IRMO:47H7:EIDB:3QZR:S3MZ:UEMP:J6J5",
      "kty": "EC",
      "x": "1cuD55uO-hSfHPfg6GwsShsropJD4FGQqJvU-4vnuxo",
      "y": "pv1OFj8b3B9IBFFVv91h8KGPj3Xs4L2gR4AgMRV2IDA"
    }
  ]
}
~~~~

#### PEM format
In addition to JSON representation of keys, PEM may also be used to
represent public keys.  The single file mode of authorized keys may
use multiple blocks to represent multiple keys.  When using a key
directory each pem file should only include a single public key block.
Each PEM block should have the type "PUBLIC KEY".  Adding other
block types will not be parsed and cause an error.

### Known Hosts
The known hosts list is similar to the authorized keys list by the server,
but also stores a host variable for each public key.  This additional host
variable ensures that the client is connecting to the host it is expecting
to connect to.  The identity of the host should already be known by the
client and verified on connect.  If the client does not know the identity of
the host, it is up the client to decide whether to add the host to the
known hosts list.

Like authorized keys, known hosts can be stored in a single file or a 
directory containing a single key per file.  Each key value will have a 

#### JSON format
The multiple entry JSON file contains a top level object with a "key"
field which has a value of an array of JWKs.  The single entry JWK
file will only have the JWK value.

~~~~
{
    "keys": [
        {
            "crv": "P-256",
            "hosts": [
                "localhost:8080"
            ],
            "kid": "2U42:NG6Y:2TSP:YVIQ:4LEW:4Z2G:NJYV:6JOJ:R3ST:ZBOS:JGOQ:4MXO",
            "kty": "EC",
            "x": "MikDjKvzG7oSLO4sB9mWuneRuGQW7o694nOZKWUVpCY",
            "y": "WLQGLscMaCUzvDRYt2QBKwX9mEyutymQCvywgeqwESw"
        }
    ]
}
~~~~

#### PEM format
PEM format is also allowed with the same rules as authorized keys. 
The "hosts" value will be put into a PEM header field as a comma
separated value.

#### "hosts" value
The "hosts" values are used to filter which keys will be used to 
genenerate the CA pool to verify the server.  Each host value may be a
single domain name or pattern.  The host value match logic is defined 
by the Golang [filepath Match function](http://golang.org/pkg/path/filepath/#Match).

See [FilterByHosts](http://godoc.org/github.com/docker/libtrust#FilterByHosts)

Examples
~~~~
example.com
subdomain.example.com
*.example.com
example.com:8080
~~~~

### Certificate CA pools
CA pools are auto-generated from a list of public keys and signed by the
private key associated with the client or server.  There is one CA 
certificate per public key.  For each certificate, the subject's common
name is set to the public key fingerprint and issuer's common name set to
the fingerprint of the private key.  Each certificate should have the CA
basic constraint set to true and the public key set as the subject's public
key.

See [GenerateCACertPool](http://godoc.org/github.com/docker/libtrust#GenerateCACertPool)

### Client Certificates
The client certificate is a self-signed certificate with the common name
set to the client key's fingerprint and "ClientAuth" set to true.

See [GenerateSelfSignedClientCert](http://godoc.org/github.com/docker/libtrust#GenerateSelfSignedClientCert)

### Server Certificates
The server certificate is a self-signed certificate with the common name
set to the server key's fingerprint, "ServerAuth" set to true, and
domains and ip addresses set to any provided value.

See [GenerateSelfSignedServerCert](http://godoc.org/github.com/docker/libtrust#GenerateSelfSignedServerCert)